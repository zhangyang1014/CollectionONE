# 批量分案功能测试指南

## 一、测试前准备

### 1. 数据库初始化

执行SQL脚本创建表和测试数据：

```bash
# 连接数据库
mysql -u root -p

# 选择数据库
USE cco_database;

# 执行初始化脚本
source /Users/zhangyang/Documents/GitHub/CollectionONE/backend-java/初始化批量分案功能.sql
```

或者在MySQL客户端中直接执行：

```sql
-- 执行 backend-java/初始化批量分案功能.sql 文件内容
```

### 2. 启动后端服务

```bash
cd /Users/zhangyang/Documents/GitHub/CollectionONE/backend-java
./start.sh
```

确认服务启动成功：
- 查看日志：`tail -f backend-java.log`
- 访问：http://localhost:8080/api/v1/cases

### 3. 启动前端服务

```bash
cd /Users/zhangyang/Documents/GitHub/CollectionONE/frontend
npm run dev
```

访问：http://localhost:5173

---

## 二、API接口测试

### 测试工具
- Postman
- curl
- 浏览器开发者工具

### 测试1：获取催员列表

**接口：** GET /api/v1/cases/collectors-for-assign

**测试用例1.1：** 获取所有催员
```bash
curl -X GET "http://localhost:8080/api/v1/cases/collectors-for-assign" \
  -H "Content-Type: application/json"
```

**预期结果：**
```json
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "id": 1,
      "collectorName": "催员张三",
      "collectorCode": "C001",
      "agencyId": 1,
      "agencyName": "测试机构A",
      "teamId": 1,
      "teamName": "测试小组1",
      "queueId": 1,
      "queueName": "M1队列",
      "currentCaseCount": 0,
      "status": "active"
    },
    // ... 更多催员
  ]
}
```

**测试用例1.2：** 按机构筛选
```bash
curl -X GET "http://localhost:8080/api/v1/cases/collectors-for-assign?agency_id=1"
```

**测试用例1.3：** 按小组筛选
```bash
curl -X GET "http://localhost:8080/api/v1/cases/collectors-for-assign?team_id=1"
```

**测试用例1.4：** 搜索催员
```bash
curl -X GET "http://localhost:8080/api/v1/cases/collectors-for-assign?search_keyword=张三"
```

---

### 测试2：检查队列限制

**接口：** POST /api/v1/cases/check-queue-limit

**测试用例2.1：** 队列匹配（不触发限制）
```bash
curl -X POST "http://localhost:8080/api/v1/cases/check-queue-limit" \
  -H "Content-Type: application/json" \
  -d '{
    "caseIds": [1, 2, 3],
    "collectorIds": [1, 2]
  }'
```

**预期结果：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "hasLimit": false,
    "unmatchedItems": []
  }
}
```

**测试用例2.2：** 队列不匹配（触发限制）
```bash
curl -X POST "http://localhost:8080/api/v1/cases/check-queue-limit" \
  -H "Content-Type: application/json" \
  -d '{
    "caseIds": [1, 2],
    "collectorIds": [3]
  }'
```

**预期结果：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "hasLimit": true,
    "unmatchedItems": [
      {
        "caseId": 1,
        "caseCode": "CASE001",
        "caseQueueId": 1,
        "caseQueueName": "M1队列",
        "collectorId": 3,
        "collectorName": "催员王五",
        "collectorTeamQueueId": 2,
        "collectorTeamQueueName": "M2队列"
      }
    ]
  }
}
```

---

### 测试3：批量分配案件

**接口：** POST /api/v1/cases/batch-assign

**测试用例3.1：** 平均分配（不忽略队列限制）
```bash
curl -X POST "http://localhost:8080/api/v1/cases/batch-assign" \
  -H "Content-Type: application/json" \
  -d '{
    "caseIds": [1, 2, 3],
    "collectorIds": [1, 2],
    "ignoreQueueLimit": false
  }'
```

**预期结果：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "successCount": 3,
    "failureCount": 0,
    "assignments": [
      {
        "caseId": 1,
        "collectorId": 1,
        "status": "success"
      },
      {
        "caseId": 2,
        "collectorId": 2,
        "status": "success"
      },
      {
        "caseId": 3,
        "collectorId": 1,
        "status": "success"
      }
    ]
  }
}
```

**验证分配结果：**
```sql
SELECT 
    id,
    case_code,
    collector_id,
    team_id,
    agency_id,
    assigned_at
FROM cases
WHERE id IN (1, 2, 3);
```

**测试用例3.2：** 突破队列限制分配
```bash
curl -X POST "http://localhost:8080/api/v1/cases/batch-assign" \
  -H "Content-Type: application/json" \
  -d '{
    "caseIds": [4, 5],
    "collectorIds": [1],
    "ignoreQueueLimit": true
  }'
```

**验证分配记录：**
```sql
SELECT 
    ca.id,
    ca.case_id,
    ca.collector_id,
    ca.assigned_by,
    ca.assigned_at,
    ca.ignore_queue_limit,
    c.case_code,
    col.collector_name
FROM case_assignments ca
LEFT JOIN cases c ON ca.case_id = c.id
LEFT JOIN collectors col ON ca.collector_id = col.id
ORDER BY ca.id DESC
LIMIT 10;
```

---

## 三、前端功能测试

### 测试场景1：批量选择案件

1. 登录系统
2. 进入案件列表页面
3. 勾选多个案件（至少2个）
4. 验证批量操作工具栏显示
5. 验证显示的案件数量正确

**预期结果：**
- ✅ 批量操作工具栏显示
- ✅ 显示"已选择 X 个案件"
- ✅ "批量分案"按钮可点击

---

### 测试场景2：打开分案弹窗

1. 选择案件后点击"批量分案"按钮
2. 验证分案弹窗打开
3. 验证催员列表加载

**预期结果：**
- ✅ 分案弹窗打开
- ✅ 显示"已选择 X 个案件"提示
- ✅ 催员列表正常加载
- ✅ 显示催员的机构、小组、队列、持案量信息

---

### 测试场景3：筛选催员

**测试3.1：按机构筛选**
1. 选择机构下拉框
2. 选择一个机构
3. 验证催员列表更新

**预期结果：**
- ✅ 只显示该机构的催员
- ✅ 小组下拉框显示该机构的小组

**测试3.2：按小组筛选**
1. 选择小组下拉框
2. 选择一个小组
3. 验证催员列表更新

**预期结果：**
- ✅ 只显示该小组的催员
- ✅ 队列下拉框显示该小组的队列

**测试3.3：按队列筛选**
1. 选择队列下拉框
2. 选择一个队列
3. 验证催员列表更新

**预期结果：**
- ✅ 只显示该队列的催员

---

### 测试场景4：搜索催员

1. 在搜索框输入催员名称（如"张三"）
2. 验证催员列表更新
3. 在搜索框输入催员ID（如"C001"）
4. 验证催员列表更新

**预期结果：**
- ✅ 搜索结果正确
- ✅ 支持模糊搜索（催员名）
- ✅ 支持精确搜索（催员ID）

---

### 测试场景5：选择催员分配

1. 勾选1个或多个催员
2. 点击"平均分案"按钮
3. 验证分配流程

**预期结果：**
- ✅ 至少选择1个催员才能点击"平均分案"
- ✅ 点击后触发队列限制检查

---

### 测试场景6：队列限制检查

**测试6.1：队列匹配（不触发限制）**
1. 选择CASE001-CASE003（M1队列）
2. 选择C001、C002（M1队列的催员）
3. 点击"平均分案"

**预期结果：**
- ✅ 直接执行分配，不弹出队列限制确认弹窗
- ✅ 分配成功提示
- ✅ 案件列表刷新

**测试6.2：队列不匹配（触发限制）**
1. 选择CASE001-CASE002（M1队列）
2. 选择C003（M2队列的催员）
3. 点击"平均分案"

**预期结果：**
- ✅ 弹出队列限制确认弹窗
- ✅ 显示不匹配详情
- ✅ 显示案件编号、案件队列、催员名、小组队列
- ✅ 提示"是否忽略队列限制？"

**测试6.3：选择"否，返回修改"**
1. 在队列限制确认弹窗中点击"否"

**预期结果：**
- ✅ 队列限制弹窗关闭
- ✅ 返回分案弹窗
- ✅ 保持当前选择状态

**测试6.4：选择"是，忽略限制继续分配"**
1. 在队列限制确认弹窗中点击"是"

**预期结果：**
- ✅ 队列限制弹窗关闭
- ✅ 执行分配
- ✅ 分配成功提示
- ✅ 案件列表刷新

---

### 测试场景7：平均分配算法验证

**测试7.1：整除分配**
1. 选择6个案件
2. 选择3个催员
3. 执行分配

**预期结果：**
- ✅ 每个催员分配2个案件

**测试7.2：不整除分配**
1. 选择5个案件
2. 选择3个催员
3. 执行分配

**预期结果：**
- ✅ 2个催员分配2个案件
- ✅ 1个催员分配1个案件

**验证SQL：**
```sql
SELECT 
    collector_id,
    COUNT(*) AS case_count
FROM cases
WHERE assigned_at > DATE_SUB(NOW(), INTERVAL 1 MINUTE)
GROUP BY collector_id;
```

---

### 测试场景8：分配历史记录

1. 执行分配后，查询分配记录

```sql
SELECT 
    ca.id,
    c.case_code,
    col.collector_name,
    ca.assigned_at,
    ca.ignore_queue_limit
FROM case_assignments ca
LEFT JOIN cases c ON ca.case_id = c.id
LEFT JOIN collectors col ON ca.collector_id = col.id
ORDER BY ca.id DESC
LIMIT 10;
```

**预期结果：**
- ✅ 每次分配都有记录
- ✅ 记录包含case_id、collector_id、assigned_by、assigned_at
- ✅ 正确记录ignore_queue_limit字段

---

## 四、边界测试

### 边界1：选择0个案件
1. 不选择任何案件
2. 点击"批量分案"（应该不可见）

**预期结果：**
- ✅ 批量操作工具栏不显示
- ✅ 无法触发分案操作

---

### 边界2：选择0个催员
1. 选择案件，打开分案弹窗
2. 不选择任何催员
3. 点击"平均分案"

**预期结果：**
- ✅ "平均分案"按钮禁用
- ✅ 无法执行分配

---

### 边界3：选择1个案件分配给1个催员
1. 选择1个案件
2. 选择1个催员
3. 执行分配

**预期结果：**
- ✅ 分配成功
- ✅ 案件归属更新

---

### 边界4：选择100个案件分配给1个催员
1. 选择100个案件
2. 选择1个催员
3. 执行分配

**预期结果：**
- ✅ 分配成功（可能较慢）
- ✅ 所有案件归属该催员

---

### 边界5：选择已结清的案件
1. 尝试选择已结清的案件

**预期结果：**
- ✅ 已结清的案件无法选择（selectable=false）
- ✅ 只能选择未结清的案件

---

## 五、异常测试

### 异常1：数据库连接失败
1. 停止数据库服务
2. 尝试分配案件

**预期结果：**
- ✅ 显示错误提示
- ✅ 不执行分配操作

---

### 异常2：催员不存在
1. 构造请求，使用不存在的催员ID
2. 执行分配

**预期结果：**
- ✅ 返回错误信息
- ✅ 不执行分配操作

---

### 异常3：案件不存在
1. 构造请求，使用不存在的案件ID
2. 执行分配

**预期结果：**
- ✅ 返回错误信息或忽略不存在的案件
- ✅ 其他案件正常分配

---

## 六、性能测试

### 性能1：批量分配100个案件
1. 选择100个案件
2. 选择10个催员
3. 记录分配时间

**预期结果：**
- ✅ 分配时间 ≤ 5秒

---

### 性能2：催员列表查询
1. 打开分案弹窗
2. 记录催员列表加载时间

**预期结果：**
- ✅ 加载时间 ≤ 1秒

---

### 性能3：队列限制检查
1. 选择50个案件和20个催员
2. 记录队列限制检查时间

**预期结果：**
- ✅ 检查时间 ≤ 2秒

---

## 七、验收清单

### 功能完整性
- [ ] 支持批量选择案件
- [ ] 分案弹窗筛选功能正常
- [ ] 分案弹窗搜索功能正常
- [ ] 多选催员功能正常
- [ ] 平均分配算法正确
- [ ] 队列限制检查功能正常
- [ ] 突破队列限制功能正常

### 性能指标
- [ ] 批量分配100个案件响应时间 ≤ 5秒
- [ ] 催员列表查询响应时间 ≤ 1秒
- [ ] 队列限制检查响应时间 ≤ 2秒

### 数据准确性
- [ ] 分配结果准确（案件正确分配给催员）
- [ ] 平均分配均衡（案件数差异≤1）
- [ ] 队列限制检查准确
- [ ] 分配历史记录完整

### 用户体验
- [ ] 操作流程顺畅，无卡顿
- [ ] 错误提示清晰明确
- [ ] 二次确认提示清晰
- [ ] 分配成功后自动刷新列表

---

## 八、问题记录

### 问题模板

| 问题ID | 问题描述 | 重现步骤 | 预期结果 | 实际结果 | 严重程度 | 状态 |
|--------|----------|----------|----------|----------|----------|------|
| BUG-001 | 描述 | 步骤 | 预期 | 实际 | 高/中/低 | 待修复/已修复 |

---

## 九、测试总结

### 测试环境
- **后端服务：** Java 17 + Spring Boot 3.3.5
- **前端服务：** Vue 3 + Element Plus
- **数据库：** MySQL 8.0
- **测试时间：** 2025-11-27

### 测试结果
- **总测试用例数：** 
- **通过数：** 
- **失败数：** 
- **通过率：** 

### 遗留问题
- 无

### 建议
- 建议添加分配进度条显示
- 建议支持分配历史记录查询界面
- 建议添加分配撤销功能

---

**最后更新：** 2025-11-27  
**测试负责人：** 待指定








