# 自动化分案（Auto Assignment）需求文档

## 0. 文档概述

- **版本**：v0.2（优化版）
- **日期**：2025-11-12
- **撰写人**：GPT-5 Codex（产品协同草稿）
- **适用范围**：Cloudun Collection ONE 催收系统
- **设计对象**：规则引擎 + 分配策略 + 预测模拟 + 调度执行
- **更新说明**：补充容量模型设计、简化粘连策略

---

## 1. 背景与目标

### 1.1 业务背景

- 当前 C 队列存在 C-1 需人工分案、C-2 由 IVR 预催收的混合模式，分案策略依赖手动调整、代码改动，无法满足快速试错和多队列差异化配置需求。
- 催收机构、组、催员的扩张速度快，人工维护工作量高；不同客群（App/Product/商户）需动态匹配最合适的承接方。
- 需构建“可视化、可审计、可扩展、可模拟”的新一代自动化分案能力，实现“队列 → 规则 → 策略 → 执行”的闭环。

### 1.2 目标

1. 提供统一的自动化分案中台能力，实现按队列配置规则集合，自动将案件分配到机构/小组/催员。
2. 支持灵活的条件组合与分配策略（平均、金额加权、粘连优先、容量约束等），并能随时调度、重跑。
3. 提供预测与模拟工具帮助业务方提前评估产能缺口，降低策略调整风险。
4. 全链路可审计：规则配置、执行批次、分配结果、回退重跑都需保留操作日志与历史。


### 1.3 范围说明

- **包含**：策略配置界面、规则引擎、分配策略执行器、预测模型、模拟器、调度器、审计与日志。
- **不含**：案件入池逻辑、外部渠道 IVR 分配逻辑、质检与绩效计算细节（保持现状但需要读取其结果）。

---

## 2. 需求合理性与系统匹配分析

### 2.1 合理性评估

- 业务动因清晰：现有手动分案效率低、风险大，自动化可显著降低人力成本并提升响应速度。
- 功能范围完整：覆盖规则配置、执行、预测、模拟、调度等关键环节，符合成熟催收系统常见需求。
- 复杂度较高：需在规则灵活性与可维护性之间平衡，必须按阶段交付，优先保障核心分配能力。

### 2.2 当前系统能力概览

- **数据模型**：`cases`、`collection_agencies`、`collection_teams`、`collectors`、`case_queues` 已存在；`collectors` 拥有 `max_case_count`、`current_case_count` 等字段，可作为容量扩展的基础。
- **审计能力**：`case_assignment_history` 记录历史流转，具备扩展分配批次的基础。
- **字段体系**：标准字段/自定义字段及字段映射流程已建，可支持基于字段的规则筛选。
- **现有限制**：
  - 后端缺少 `/cases/assign-to-*`、`/cases/auto-assign` 的具体实现，仅有前端 API 定义。
  - 缺失规则建模、策略持久化、调度执行、预测模拟等服务。
  - 数据表无规则、批次、容量日度计数等结构，需新增。
  - 缺少统一的任务调度框架（如 Celery/Arq），目前没有定时任务能力。

### 2.3 需求匹配度摘要

| 模块 | 需求摘要 | 现有能力 | 差距评估 | 风险提示 |
| --- | --- | --- | --- | --- |
| 队列总览 | 按队列展示入催、已分、持案、剩余等指标 | 无对应页面；`cases`、`performance_stats` 可提供数据源 | 需新增统计接口与前端页面 | 需统一口径，避免与绩效统计冲突 |
| 策略列表 | 队列内策略排序、启停、日志 | 无策略实体 | 需设计策略/规则表、审核流程 | 需防止频繁变更导致执行混乱 |
| 三步向导 | 向导式配置（基础信息/条件/策略） | 前端无界面；字段配置组件可复用 | 需实现全新 UI + 后端保存接口 | 操作复杂度较高，需交互优化 |
| 规则引擎 | 支持多字段、AND/OR、运算符 | 仅有字段配置与筛选模型，未连接案件过滤 | 需实现通用规则引擎或 DSL 解析 | 性能压力，需要预估缓存策略 |
| 分配策略 | 平均、金额、粘连、容量、打散等 | `collectors` 有容量字段，无策略执行逻辑 | 需建设分配执行器、容量/负载模型 | 容量与粘连逻辑复杂，需详测 |
| 预测模拟 | 入池预测、产能模拟、导出 | 无现成能力 | 需新建数据管道与算法模块 | 预测模型需验证数据质量 |
| 调度执行 | Cron、串并行、重试、重跑 | 无定时任务；无幂等设计 | 需引入任务调度器、批次表 | 失败恢复与重跑需严谨设计 |
| 审计与日志 | 操作日志、批次追踪 | `case_assignment_history` 可扩展 | 需补充策略变更日志、批次表 | 日志量大，需规划存储周期 |

### 2.4 主要风险

1. **数据质量**：现有案件字段来自甲方同步，若字段缺失/格式异常会影响规则判断，需要完善字段校验与容错。
2. **性能压力**：大批量案件执行规则与分配可能导致数据库压力，需要批量处理、缓存、异步化设计。
3. **容量模型**：`max_case_count`、`current_case_count` 目前缺乏每日重置与统计机制，需制定数据刷新策略。
4. **上线策略**：需支持 A/B 或灰度，避免一次性全量切换导致不可控风险。

---

## 3. 术语与角色

- **队列（Queue）**：按逾期天数或其他维度划分的案件池，目标范围：C、S0、S1、L1、M1。
- **策略（Strategy）**：针对某队列的自动分案配置集合，由基础信息、条件、分配策略组成。
- **规则引擎（Rule Engine）**：根据案件字段过滤符合条件的案件集合。
- **分配策略（Assignment Strategy）**：决定符合条件的案件如何分配至机构/小组/催员。
- **预测（Forecast）**：基于历史入池数据预测未来一段时间案件量。
- **模拟（Simulation）**：使用预测结果与当前配置，估算产能缺口或过载情况。
- **调度（Schedule）**：按配置时间触发策略执行，可串并行、支持重试与重跑。
- **优先分配（Stickiness）**：保持历史跟进关系的粘连策略，优先回归原承接人。

---

## 4. 高层流程与场景

### 4.1 高层流程

1. **策略配置**：业务配置人员在队列下创建策略，设置基础信息、条件、分配策略，保存并启用。
2. **调度执行**：调度器按照配置时间触发策略，拉取待分配案件 → 执行规则引擎 → 运行分配策略 → 记录批次结果。
3. **结果回写**：更新案件归属（机构/组/催员），写入 `case_assignment_history` 与批次结果表。
4. **监控与审计**：队列总览、策略日志、批次执行日志实时更新；异常情况支持重跑与回滚。
5. **预测模拟**：业务根据预测/模拟数据调整策略或容量，形成闭环优化。

### 4.2 操作角色

- **系统管理员（Platform Admin）**：维护全局配置、字段、系统参数。
- **甲方管理员（Tenant Admin）**：管理队列、策略、调度；可创建/启停策略。
- **机构管理员（Agency Admin）**：查看所属机构策略执行结果，维护机构下容量数据。
- **组长/催员**：被动接受分配，可查看个人持案；无策略配置权限。

---

## 5. 功能需求详述

### 5.1 队列总览（Queue Dashboard）

- **展示内容**：
  - 自动分案时间段（展示 Cron 表达式及最近/下次执行时间）。
  - 今日计划入催案件数（剔除 C 队列的 C-2 IVR 预催部分）。
  - 已分配案件数（成功下发至催员）。
  - 平均持案数 = 已分配案件数 ÷ 参与分配催员数。
  - 剩余待分配案件数。
  - 指标口径说明：列出数据源字段、刷新频率、是否包含 IVR。
- **交互**：支持按队列切换、按日期维度查看历史、导出。
- **数据接口建议**：
  - 新增 `/api/v1/queues/{queue_id}/assignment-dashboard?date=2025-04-28`。
  - 后端聚合来源：`cases`、`case_assignment_history`、预估数据（见预测模块）。

### 5.2 策略列表（Strategy List）

- **列表字段**：执行顺序、策略名称、状态（开启/关闭）、分配目标（机构/组/催员）、启动时间、创建时间、最近执行状态。
- **行为规则**：
  - 同队列内按顺序执行，支持拖拽排序。
  - 仅“开启”且达到“启动时间”的策略会参与执行。
  - 支持复制策略、查看详情、启停、删除（删除需二次确认并保留日志）。
  - 显示冲突提示（例如同一催员出现在多个策略且容量风险）。
- **详情页面**：只读展示配置，含操作日志（启停、编辑、排序调整），时间倒序。

### 5.3 策略向导（Wizard）

#### 第一步：基础信息

- 展示所属队列、队列编码、时区（只读）。
- 规则名称唯一，1–50 字，支持中英文特殊字符。
- 启动时间不得早于当前时间。
- 校验通过后进入下一步。

#### 第二步：分配条件（Condition Builder）

- 支持多组 OR，组内多条件 AND。
- 字段选择范围：标准字段、自定义字段、队列字段、系统生成字段（如 `queue_code`、`overdue_days`）。
- 运算符见规则引擎章节（含数值、日期、字符串等）。
- 支持复制条件组、删除、拖拽排序。
- 实时预览：显示符合条件的案件数量预估（可调用模拟接口）。

#### 第三步：机构与策略（Agency & Strategy）

- 展示候选机构/组/催员数量与容量（仅统计“已启用且绑定该队列”的账号）。
- 配置分配策略：默认“按数量平均”，可切换“按金额平均”、“优先分配”组合。
- 优先分配开启时需选择粘连粒度（客户/客户+产品/客户+商户）。
- 容量配置：允许设置策略内对机构/组/人的容量上限与负载因子。
- 同步展示冲突与预警（如容量不足、催员被多策略覆盖）。
- 仅第三步可提交；缺失必填项时红色提示。

### 5.4 规则引擎（Rule Engine）

- **支持字段类型**：字符串、数值、布尔、日期。
- **运算符**：
  - 数值/日期：`>`、`>=`、`<`、`<=`、`between`。
  - 字符串：`=`、`!=`、`contains`、`not contains`、`in`、`not in`。
  - 布尔：`is true`、`is false`。
- **条件组合**：AND/OR 多组无限嵌套，提供复制、拖拽。
- **扩展字段**：支持引用自定义字段与外部衍生指标（需字段映射支持）。
- **性能要求**：
  - 规则执行需支持批量案件（按策略批次），建议生成 SQL 或使用向量化过滤。
  - 支持缓存策略编译结果，减少重复解析。

### 5.5 分配策略（Assignment Strategy）

- **目标层级**：机构 → 小组 → 催员，允许任意层级组合（例如只分到机构，由机构人工再分）。
- **基础分配**：
  - 按数量平均（By Count Average）。
  - 按金额平均（By Amount Average）：以 `outstanding_amount_borrow` 为权重，使用"贪心分摊 + 局部微调"，支持误差阈值、最大迭代数。
- **优先分配（Stickiness）**：
  - **阶段规划**：
    - **MVP**：暂不支持粘连功能，优先保障基础分配能力。
    - **阶段二**：仅支持"同客户"粘连（基于 `mobile_number`）。
    - **阶段三**：扩展支持"同客户+产品"、"同客户+商户"等复合粘连。
  - **粘连规则（阶段二）**：
    - 查询历史窗口：默认 30 天（可配置 7/30/90 日）。
    - 优先回归：案件优先分配给该客户历史跟进的催员。
    - 容量冲突处理：若历史催员容量不足，自动降级到基础分配，并记录降级原因。
  - **性能优化**：
    - 在 `case_assignment_history` 表上建立复合索引：`(mobile_number, assigned_at DESC, to_collector_id)`。
    - 使用 CTE（公共表表达式）预查询历史分配关系，减少 JOIN 开销。
- **容量与负载**：
  - 支持机构/组/催员三层"件数/金额"双上限。
  - 负载因子：可基于近 7/14 日完成率或绩效指标调整分配份额，需要读取 `collector_performance_stats`。
  - 冲突提示：同一催员在多策略中容量不足时给出提醒。
  - **详细设计见 6.5 节"容量模型详细设计"**。
- **排序与打散**：
  - 支持配置案件排序键（例如逾期天数倒序、金额倒序、应还日升序）。
  - 同客户多单可选择打散或合并分配。
- **幂等与重跑**：
  - 幂等键：分配批次号（Batch ID）+ `loan_id_borrow`。
  - 重跑模式：覆盖原分配、仅分未分配案件、回收后重分。需保留历史记录。

### 5.6 预测与模拟（Forecast & Simulation）

- **预测**：
  - 口径：按队列、策略条件过滤后的“每日入池案件数”。
  - 方法：近 7/14/28 日滑动均值 + 工作日季节性校正（Weekday Seasonality）；可切换简单指数平滑（SES）；提供异常值剔除（IQR 或 3σ）。
  - 输出：日均案件数区间、P50/P90、预计每人案件量（= 预测案件数 ÷ 参与催员数）。
- **模拟**：
  - 输入：预测量或当日实际量 + 当前启用催员数与容量。
  - 输出：按机构/组/催员的预计承接量、超额/缺口提示，可导出 CSV。
  - 场景：策略调优前评估，节假日/营销日特殊情境。

### 5.7 执行与调度（Execution & Schedule）

- **时间配置**：每日固定时刻或多时段 Cron（精确到分钟），清晰展示时区。
- **执行顺序**：同队列内策略串行执行，不同队列可并行。
- **失败重试**：指数退避（指数退避参数可配置，默认最大重试 3 次）。
- **状态监控**：执行结果需包含成功/失败/跳过原因，实时展示在策略列表及日志中。
- **重跑**：支持对历史批次发起重跑，需选择模式（覆盖/仅未分配/回收重分），并记录操作人。

---

## 6. 数据与模型需求

### 6.1 借款记录（Borrow Record）

- **必填**：`loan_id_borrow`、`mobile_number`。
- **基础字段**：`app_name`、`product_name`、`collection_type`、`due_date_borrow`、`overdue_days_borrow`、`outstanding_amount_borrow`、`binder`、`case_status_borrow`、`settlement_method`、`settlement_time`、`latest_result`、`last_collection_time`、`operator`。
- **拓展字段**：`merchant_name`、`system_name`、`app_download_url`、`reborrow_flag`、`auto_reloan`、`first_term_days`、`remark`、`principal_due_borrow`、`interest_due_borrow`。

### 6.2 机构/小组/催员元数据

- **机构**：编码、名称、状态、绑定队列、启用状态、容量上限（件数/金额）、作息时段。
- **小组**：编码、名称、状态、绑定队列、成员数、容量上限。
- **催员**：账号、姓名、状态、绑定队列、当日可用容量、负载因子、绩效指标。

### 6.3 字段校验

- `loan_id_borrow`：字符串 1–64。
- `mobile_number`：多国家手机号校验（需支持可配置规则）。
- 日期字段：ISO 8601，结清时间不可早于应还日期。
- 金额字段：非负数，最多两位小数。

### 6.4 新增数据实体建议

1. `assignment_strategies`：策略主表（策略名称、队列、启动时间、状态、排序、创建者、更新时间等）。
2. `assignment_conditions`：条件组与条件项表，保存规则引擎定义。
3. `assignment_targets`：策略目标（机构/组/催员）、容量、负载因子、排序等。
4. `assignment_batches`：执行批次表（批次号、策略 ID、执行时间、状态、执行数量、模式、重跑来源等）。
5. `collector_daily_capacity`：催员每日容量表（详见 6.5 节）。
6. `assignment_logs`：策略操作日志（启停、编辑、排序、上线、回滚）。

### 6.5 容量模型详细设计

#### 6.5.1 设计目标

解决现有 `collectors` 表中 `max_case_count`、`current_case_count` 字段缺乏日度重置、实时扣减、超限处理等机制的问题。

#### 6.5.2 数据表设计

**新增表：`collector_daily_capacity`**

```sql
CREATE TABLE collector_daily_capacity (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    collector_id BIGINT NOT NULL COMMENT '催员ID',
    tenant_id BIGINT NOT NULL COMMENT '甲方ID（用于隔离）',
    stat_date DATE NOT NULL COMMENT '统计日期',
    
    -- 容量配置
    max_capacity INT NOT NULL DEFAULT 100 COMMENT '每日案件上限',
    max_amount DECIMAL(15, 2) COMMENT '每日金额上限（可选）',
    
    -- 实时计数
    assigned_count INT NOT NULL DEFAULT 0 COMMENT '已分配案件数',
    assigned_amount DECIMAL(15, 2) NOT NULL DEFAULT 0 COMMENT '已分配金额',
    
    -- 计算字段（可用虚拟列或应用层计算）
    available_count INT GENERATED ALWAYS AS (max_capacity - assigned_count) STORED COMMENT '可用案件容量',
    available_amount DECIMAL(15, 2) GENERATED ALWAYS AS (max_amount - assigned_amount) STORED COMMENT '可用金额容量',
    
    -- 预锁定（用于模拟/重跑场景）
    locked_count INT NOT NULL DEFAULT 0 COMMENT '预锁定案件数',
    locked_amount DECIMAL(15, 2) NOT NULL DEFAULT 0 COMMENT '预锁定金额',
    
    -- 元数据
    reset_at TIMESTAMP COMMENT '最后重置时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_collector_date (collector_id, stat_date),
    INDEX idx_tenant_date (tenant_id, stat_date),
    INDEX idx_available (collector_id, stat_date, available_count)
) COMMENT='催员每日容量表';
```

#### 6.5.3 容量刷新策略

**1. 每日自动重置**

- **时间**：每日凌晨 00:05（避开 00:00 高峰）
- **逻辑**：
  ```python
  # 定时任务（Celery Beat 或 APScheduler）
  def reset_daily_capacity():
      today = date.today()
      
      # 为所有启用催员初始化今日容量
      active_collectors = db.query(Collector).filter(
          Collector.is_active == True,
          Collector.status == 'active'
      ).all()
      
      for collector in active_collectors:
          db.merge(CollectorDailyCapacity(
              collector_id=collector.id,
              tenant_id=collector.tenant_id,
              stat_date=today,
              max_capacity=collector.max_case_count,  # 从催员配置读取
              assigned_count=0,
              assigned_amount=0,
              locked_count=0,
              locked_amount=0,
              reset_at=datetime.now()
          ))
      
      db.commit()
  ```

**2. 实时扣减机制**

- **分配时原子操作**：
  ```python
  def assign_cases_to_collector(collector_id, case_ids, stat_date):
      # 计算待分配案件数和金额
      cases = db.query(Case).filter(Case.id.in_(case_ids)).all()
      count = len(cases)
      amount = sum(c.outstanding_amount for c in cases)
      
      # 原子更新容量（使用数据库行锁）
      result = db.execute(
          """
          UPDATE collector_daily_capacity
          SET assigned_count = assigned_count + :count,
              assigned_amount = assigned_amount + :amount
          WHERE collector_id = :collector_id 
            AND stat_date = :stat_date
            AND available_count >= :count  -- 容量校验
          """,
          {
              'count': count,
              'amount': amount,
              'collector_id': collector_id,
              'stat_date': stat_date
          }
      )
      
      if result.rowcount == 0:
          raise InsufficientCapacityError(
              f"催员 {collector_id} 容量不足，需要 {count} 件，可用 {available}"
          )
      
      # 更新案件归属
      for case in cases:
          case.collector_id = collector_id
          case.assigned_at = datetime.now()
      
      db.commit()
  ```

#### 6.5.4 超限处理策略

**配置项**：`capacity_limit_mode`

| 模式 | 说明 | 行为 |
|------|------|------|
| **hard**（硬限制） | 严格容量上限 | 超限时拒绝分配，记录日志，触发告警 |
| **soft**（软限制） | 允许超限 10% | 超限 10% 内允许分配，发出告警；超 10% 拒绝 |
| **unlimited**（无限制） | 仅统计不限制 | 仅记录数据，不阻止分配 |

**实现示例**：

```python
def check_capacity(collector_id, required_count, stat_date, mode='hard'):
    capacity = db.query(CollectorDailyCapacity).filter(
        CollectorDailyCapacity.collector_id == collector_id,
        CollectorDailyCapacity.stat_date == stat_date
    ).first()
    
    if not capacity:
        raise CapacityNotInitializedError()
    
    if mode == 'unlimited':
        return True
    
    available = capacity.available_count
    
    if mode == 'hard':
        if available < required_count:
            log_capacity_exceeded(collector_id, required_count, available)
            return False
        return True
    
    if mode == 'soft':
        soft_limit = capacity.max_capacity * 1.1  # 允许超 10%
        if capacity.assigned_count + required_count <= soft_limit:
            if available < required_count:
                alert_capacity_warning(collector_id, required_count, available)
            return True
        else:
            log_capacity_exceeded(collector_id, required_count, available)
            return False
```

#### 6.5.5 预锁定机制（用于模拟）

**场景**：执行模拟时需要"虚拟占用"容量，但不实际分配案件。

```python
def simulate_assignment(strategy_id, dry_run=True):
    # 模拟分配逻辑
    assignments = calculate_assignments(strategy_id)
    
    if dry_run:
        # 预锁定容量
        for collector_id, case_count in assignments.items():
            db.execute(
                """
                UPDATE collector_daily_capacity
                SET locked_count = locked_count + :count
                WHERE collector_id = :collector_id AND stat_date = :date
                """,
                {'count': case_count, 'collector_id': collector_id, 'date': date.today()}
            )
        
        # 返回模拟结果
        result = generate_simulation_report(assignments)
        
        # 释放锁定
        rollback_locks(assignments)
        
        return result
    else:
        # 实际分配
        execute_real_assignment(assignments)
```

#### 6.5.6 容量监控与告警

**监控指标**：

1. **容量使用率**：`assigned_count / max_capacity * 100%`
2. **超限次数**：每日拒绝分配的次数
3. **平均持案数**：`SUM(assigned_count) / COUNT(DISTINCT collector_id)`

**告警规则**：

- 容量使用率 > 90%：预警
- 容量使用率 = 100%：告警
- 连续 3 次超限拒绝：紧急告警
- 某催员容量为 0 但仍有分配请求：配置异常告警

#### 6.5.7 历史数据与报表

- **保留周期**：90 天在线，1 年归档
- **用途**：
  - 容量趋势分析
  - 催员负载均衡评估
  - 容量规划（预测未来需要的催员数）

---

## 7. 系统设计要点

### 7.1 架构建议

- **服务层**：新增分案服务（Assignment Service），负责策略编排、规则执行、分配计算、批次记录。
- **任务调度**：建议引入 Celery/Redis Queue + Beat，或使用 APScheduler（需注意高可用）。
- **规则执行**：可采用 DSL → SQL 转换，或基于 Pandas/Polars 的内存计算（需评估数据量）。
- **分配算法**：按数量/金额平均可采用贪心 + 回溯，粘连需查询历史分配（可利用 `case_assignment_history`）。

### 7.2 性能与扩展

- 对大批量案件执行需分批处理（例如每 500/1000 条一批），并使用数据库批量更新。
- **粘连查询优化**（阶段二）：
  - 在 `case_assignment_history` 上建立复合索引：`CREATE INDEX idx_assignment_history_lookup ON case_assignment_history(mobile_number, assigned_at DESC, to_collector_id)`。
  - 使用 CTE 预查询历史分配关系，示例 SQL：
    ```sql
    WITH recent_assignments AS (
        SELECT DISTINCT ON (mobile_number) 
            mobile_number, 
            to_collector_id as preferred_collector_id
        FROM case_assignment_history
        WHERE assigned_at >= CURRENT_DATE - INTERVAL '30 days'
        ORDER BY mobile_number, assigned_at DESC
    )
    SELECT c.*, ra.preferred_collector_id
    FROM cases c
    LEFT JOIN recent_assignments ra ON c.mobile = ra.mobile_number
    WHERE c.queue_id = ? AND c.collector_id IS NULL;
    ```
- **容量查询优化**：
  - 高频读取场景可将 `collector_daily_capacity` 缓存到 Redis，TTL 5 分钟。
  - 分配时直接查询数据库并加行锁，保证原子性。

### 7.3 审计与回溯

- 所有配置变更写入 `assignment_logs`，记录旧值、新值、操作人、操作时间。
- 批次执行记录包括：输入参数、过滤案件数、分配结果、失败原因。
- 调度器需记录触发日志，方便排查未执行、执行失败等问题。

---

## 8. 接口与前端交互

### 8.1 后端接口（示例）

- `GET /api/v1/queues/{queue_id}/strategies`：获取策略列表。
- `POST /api/v1/queues/{queue_id}/strategies`：新建策略。
- `PUT /api/v1/strategies/{strategy_id}`：编辑策略。
- `PATCH /api/v1/strategies/{strategy_id}/status`：启停。
- `POST /api/v1/strategies/{strategy_id}/simulation`：执行模拟。
- `POST /api/v1/strategies/{strategy_id}/run`：手动触发执行/重跑。
- `GET /api/v1/assignment-batches`：查询执行批次结果。
- `GET /api/v1/queues/{queue_id}/dashboard`：队列总览。

### 8.2 前端模块

- `QueueDashboard.vue`：展示监控指标。
- `StrategyList.vue`：列表、排序、日志。
- `StrategyWizard.vue`：三步向导。
- `SimulationDrawer.vue`：预测/模拟面板。
- 复用现有字段选择器、机构/组/催员选择组件。

---

## 9. 权限与安全

- 权限点建议：
  - `assignment.strategy.view` / `edit` / `delete` / `publish`。
  - `assignment.simulation.run`。
  - `assignment.batch.view` / `rerun`。
- 日志需包含租户（Tenant）隔离，避免跨租户访问。
- 批量操作需审计字段（IP、User Agent、操作人）。

---

## 10. 运维与监控

- 监控指标：
  - 策略执行耗时、成功率、失败率。
  - 队列待分配案件数、平均持案数。
  - 分配粘连命中率、容量超限次数。
- 告警：
  - 调度失败连续 N 次。
  - 某策略执行结果异常（例如分配数量过低）。
  - 容量/负载超限。
- 日志存储：建议 90 天在线，归档 1 年。

---

## 11. 里程碑与实施建议

1. **MVP（2~3 周）**：
   - 实现策略模型、规则过滤、按数量平均、调度执行、基础日志、手动触发。
   - 覆盖 C 队列 C-1 核心场景。
2. **阶段二**：
   - 引入金额平均、粘连优先、容量管理、冲突提示、模拟能力。
3. **阶段三**：
   - 完成预测模型、打散策略、全面调度（Cron + 并行）、重跑模式。
4. **优化阶段**：
   - 指标监控、智能推荐、A/B 测试、自动调参与容量预测。

---

## 12. 待确认事项

1. 是否需要支持跨队列策略（例如 S1 和 L1 共用一条策略）？
2. ~~粘连优先的历史窗口（7/30/90 日？）与优先级（不同粒度之间的优先顺序）。~~（已明确：阶段二仅支持同客户粘连，默认 30 日窗口）
3. 预测模型的数据来源是否只依赖本系统？是否需要接入外部 BI。
4. ~~容量上限的重置频率（按日凌晨重置？手动重置？）与异常处理。~~（已明确：每日 00:05 自动重置，支持硬/软/无限制三种模式）
5. 是否需要支持回滚到"未分配状态"或回滚到指定策略执行前的状态。
6. 容量超限时的业务处理流程（是否需要人工介入审批？是否自动调整策略？）。
7. 粘连降级到基础分配时，是否需要通知相关人员（如组长）？

---

## 13. 附录

### 13.1 参考数据表

**现有表**：
- `cases`、`case_assignment_history`、`collection_agencies`、`collection_teams`、`collectors`、`collector_performance_stats`、`case_queues`

**新增表**：
- `assignment_strategies`、`assignment_conditions`、`assignment_targets`、`assignment_batches`、`collector_daily_capacity`、`assignment_logs`

### 13.2 相关文档

- 《甲方字段匹配流程技术文档》v1.0.0
- 《数据库初始化和运行指南》

### 13.3 名词对照

- Auto Assignment = 自动化分案
- Stickiness = 粘连/优先分配
- Forecast = 入池预测
- Simulation = 承载模拟
- Capacity = 容量
- Hard Limit = 硬限制
- Soft Limit = 软限制

### 13.4 关键索引建议

```sql
-- 案件分配历史表（用于粘连查询）
CREATE INDEX idx_assignment_history_lookup 
ON case_assignment_history(mobile_number, assigned_at DESC, to_collector_id);

-- 案件表（用于规则过滤）
CREATE INDEX idx_cases_assignment 
ON cases(queue_id, collector_id, created_at) 
WHERE collector_id IS NULL;

-- 催员表（用于容量查询）
CREATE INDEX idx_collector_capacity 
ON collectors(is_active, max_case_count, current_case_count);

-- 每日容量表（用于快速查询可用容量）
CREATE INDEX idx_daily_capacity_available 
ON collector_daily_capacity(collector_id, stat_date, available_count);
```

### 13.5 版本更新记录

| 版本 | 日期 | 更新内容 | 作者 |
|------|------|----------|------|
| v0.1 | 2025-11-12 | 初版需求文档 | GPT-5 Codex |
| v0.2 | 2025-11-12 | 补充容量模型详细设计、简化粘连策略 | GPT-5 Codex |

---

> **注**：本需求文档基于当前代码库（截至 2025-11-12）调研结论撰写，后续如架构/数据发生变更需同步更新。
> 
> **重点优化**：
> 1. ✅ 新增 `collector_daily_capacity` 表，实现日度容量管理
> 2. ✅ 粘连策略分阶段实施，阶段二仅支持同客户粘连
> 3. ✅ 明确容量超限处理策略（硬/软/无限制）
> 4. ✅ 提供完整的索引优化建议与 SQL 示例

